# First verison of a simple linear regression algorithm in MAMBA, the
# MPC language of the SCALE-MAMBA library
# The algorithm is an adapted verison of the one to be found here:
# https://machinelearningmastery.com/implement-simple-linear-regression-scratch-python/

# Author: Florian Apfelbeck, July, 2018

# TODO:
# - Enable external input of sint arrays
# - implement ability to split arrays
# - commment code
# - Ensure correct function of code and testing
# - improve multiple additions to same value, e.g., in sum function
# (do not use arrays but MemValue)
# - create README elaborating how to run this with documentation of changes in
# SCALE-MAMBA source code (files IO.h, Player.cpp and new Input_OUtput_* files)
# - consider implementing possibility for external input of sfloats into the
# SCALE-MAMBA library

from Compiler import mpc_math, floatingpoint

sfloat.vlen = 15 # Length of mantissa in bits
sfloat.plen = 10 # Length of exponent in bits
sfloat.kappa = 4 # Statistical security parameter for floats

NULL = -123456789

# data input quick fix
x_tr = sfloat.Array(38)
# - consider creating vector style array (with pointer to end_ptr)
x_te = sfloat.Array(25)
y_tr = sfloat.Array(38)
y_te = sfloat.Array(25)

x_tr[0] = sfloat(108)
y_tr[0] = sfloat(392.5)
x_tr[1] = sfloat(19)
y_tr[1] = sfloat(46.2)
x_tr[2] = sfloat(13)
y_tr[2] = sfloat(15.7)
x_tr[3] = sfloat(124)
y_tr[3] = sfloat(422.2)
x_tr[4] = sfloat(40)
y_tr[4] = sfloat(119.4)
x_tr[5] = sfloat(57)
y_tr[5] = sfloat(170.9)
x_tr[6] = sfloat(23)
y_tr[6] = sfloat(56.9)
x_tr[7] = sfloat(14)
y_tr[7] = sfloat(77.5)
x_tr[8] = sfloat(45)
y_tr[8] = sfloat(214)
x_tr[9] = sfloat(10)
y_tr[9] = sfloat(65.3)
x_tr[10] = sfloat(5)
y_tr[10] = sfloat(20.9)
x_tr[11] = sfloat(48)
y_tr[11] = sfloat(248.1)
x_tr[12] = sfloat(11)
y_tr[12] = sfloat(23.5)
x_tr[13] = sfloat(23)
y_tr[13] = sfloat(39.6)
x_tr[14] = sfloat(7)
y_tr[14] = sfloat(48.8)
x_tr[15] = sfloat(2)
y_tr[15] = sfloat(6.6)
x_tr[16] = sfloat(24)
y_tr[16] = sfloat(134.9)
x_tr[17] = sfloat(6)
y_tr[17] = sfloat(50.9)
x_tr[18] = sfloat(3)
y_tr[18] = sfloat(4.4)
x_tr[19] = sfloat(23)
y_tr[19] = sfloat(113)
x_tr[20] = sfloat(6)
y_tr[20] = sfloat(14.8)
x_tr[21] = sfloat(9)
y_tr[21] = sfloat(48.7)
x_tr[22] = sfloat(9)
y_tr[22] = sfloat(52.1)
x_tr[23] = sfloat(3)
y_tr[23] = sfloat(13.2)
x_tr[24] = sfloat(29)
y_tr[24] = sfloat(103.9)
x_tr[25] = sfloat(7)
y_tr[25] = sfloat(77.5)
x_tr[26] = sfloat(4)
y_tr[26] = sfloat(11.8)
x_tr[27] = sfloat(20)
y_tr[27] = sfloat(98.1)
x_tr[28] = sfloat(7)
y_tr[28] = sfloat(27.9)
x_tr[29] = sfloat(4)
y_tr[29] = sfloat(38.1)
x_tr[30] = sfloat(0)
y_tr[30] = sfloat(0)
x_tr[31] = sfloat(25)
y_tr[31] = sfloat(69.2)
x_tr[32] = sfloat(6)
y_tr[32] = sfloat(14.6)
x_tr[33] = sfloat(5)
y_tr[33] = sfloat(40.3)
x_tr[34] = sfloat(22)
y_tr[34] = sfloat(161.5)
x_tr[35] = sfloat(11)
y_tr[35] = sfloat(57.2)
x_tr[36] = sfloat(61)
y_tr[36] = sfloat(217.6)
x_tr[37] = sfloat(12)
y_tr[37] = sfloat(58.1)
x_te[0] = sfloat(4)
y_te[0] = sfloat(12.6)
x_te[1] = sfloat(16)
y_te[1] = sfloat(59.6)
x_te[2] = sfloat(13)
y_te[2] = sfloat(89.9)
x_te[3] = sfloat(60)
y_te[3] = sfloat(202.4)
x_te[4] = sfloat(41)
y_te[4] = sfloat(181.3)
x_te[5] = sfloat(37)
y_te[5] = sfloat(152.8)
x_te[6] = sfloat(55)
y_te[6] = sfloat(162.8)
x_te[7] = sfloat(41)
y_te[7] = sfloat(73.4)
x_te[8] = sfloat(11)
y_te[8] = sfloat(21.3)
x_te[9] = sfloat(27)
y_te[9] = sfloat(92.6)
x_te[10] = sfloat(8)
y_te[10] = sfloat(76.1)
x_te[11] = sfloat(3)
y_te[11] = sfloat(39.9)
x_te[12] = sfloat(17)
y_te[12] = sfloat(142.1)
x_te[13] = sfloat(13)
y_te[13] = sfloat(93)
x_te[14] = sfloat(13)
y_te[14] = sfloat(31.9)
x_te[15] = sfloat(15)
y_te[15] = sfloat(32.1)
x_te[16] = sfloat(8)
y_te[16] = sfloat(55.6)
x_te[17] = sfloat(29)
y_te[17] = sfloat(133.3)
x_te[18] = sfloat(30)
y_te[18] = sfloat(194.5)
x_te[19] = sfloat(24)
y_te[19] = sfloat(137.9)
x_te[20] = sfloat(9)
y_te[20] = sfloat(87.4)
x_te[21] = sfloat(31)
y_te[21] = sfloat(209.8)
x_te[22] = sfloat(14)
y_te[22] = sfloat(95.5)
x_te[23] = sfloat(53)
y_te[23] = sfloat(244.6)
x_te[24] = sfloat(26)
y_te[24] = sfloat(187.5)

MAX_ARRAY_LENGTH = 10000


## Next # TODO:
#1. Split
# 2. Comments
# 3. test


############ preliminary implemetation of svector. To be improved ##############
# TODO implement NULL as end_ptr+1
class CustVector(object):

    def __init__(self):
        self.s_vector = sint.Array(MAX_ARRAY_LENGTH)
        self.end_ptr = MemValue(-1)
        self.s_vector[0] = NULL

    @method_block
    def pop_back(self):
        element = self.s_vector[self.end_ptr]
        self.s_vector[self.end_ptr] = NULL
        self.end_ptr.write(self.end_ptr - 1)
        return element

    @method_block
    def push_back(self, element):
        self.end_ptr.write(self.end_ptr + 1)
        self.s_vector[self.end_ptr] = element
        self.s_vector[self.end_ptr + 1] = NULL

    @method_block
    def back(self):
        if_then(self.end_ptr == -1)
        result = sint(NULL)
        else_then()
        result = self.s_vector[self.end_ptr]
        end_if()
        return result

    @method_block
    def length(self):
        return self.end_ptr + 1

    @method_block
    def show(self):
        @for_range(20)
        #@for_range(self.end_ptr)
        def _(i):
            print_ln("%s", self.s_vector[i].reveal())

###########################################################################
######################### read in using list (not working, to be deleted) #################
# open_channel(5)
# # m = MemValue(cint(1))
# input_list = [sint(3)]
#
# @do_while
# def _():
#     input = sint.get_private_input_from(1)
#     if_then(input.reveal())
#     print_ln("%s", input.reveal())
#     input_list.insert(len(input_list),input)
#     print_ln("%s", input_list[1].reveal())
#     else_then()
#     m.write(0)
#     print_ln("end of input")
#     end_if()
#     return m > 0

# a = 0
# for i in range(MAX_ARRAY_LENGTH):
#     input = sint.get_private_input_from(1)
#     print_ln("%s", input.reveal())
#
#     if input.reveal() != 0:
#         input_list.append(input)
#         a = a + 1
#         print_ln("%s", a)
#     elif input.reveal() == 0:
#         print_ln("end of input")
#         break
#
# print_ln("======================")
# print_ln("list 0 %s", input_list[0].reveal())
# # print_ln("list 1 %s", input_list[1].reveal())
# # print_ln("list 2 %s", input_list[2].reveal())
# # print_ln("list 3 %s", input_list[3].reveal())
# # print_ln("list 4 %s", input_list[4].reveal())
# print_ln("======================")
#
# # @for_range(15)
# # def _(i):
# #     print_ln("----------list----")
# #
# #     element = input_list.pop()
# #     print_ln(" %s", element.reveal())

# close_channel(5)


#####################################
#
#
# test = sint(-10000000000000000)
# print_ln("test========== %s", test.reveal())
#


################################################################################
####################### loading of external private dataset ####################
# naive implementation (with preknown and defined input sizes)
# Y_ARRAY_LENGTH = 15+4
# y = sint.Array(Y_ARRAY_LENGTH)
# X_ARRAY_LENGTH = 15+4
# x = sint.Array(X_ARRAY_LENGTH)

# def get_external_private_array(channel, player):
#     open_channel(channel)
#     array = sint.Array(X_ARRAY_LENGTH)
#
#     condition = MemValue(cint(1))
#     i = MemValue(cint(0))
#
#     @do_while
#     def _():
#         input = sint.get_private_input_from(player)
#         #print_ln("input reveal %s", input.reveal())
#
#         if_then(input.reveal() != NULL)
#         array[i] = input
#         i.write(i + 1)
#         #print_ln("input available")
#
#         else_then()
#         condition.write(0)
#         #print_ln("end of input")
#         array[i] = NULL
#         end_if()
#
#         print_ln("%s", condition)
#         close_channel(channel)
#         return condition > 0
#     print_ln("---------")
#     print_ln("x:\n")
#     @for_range(19)
#     def _(i):
#         print_ln("%s", array[i].reveal())
#     print_ln("---------")
#
#
#     return array

def get_external_private_array(cust_vector, channel, player):
    open_channel(channel)
    condition = MemValue(cint(1))
    i = MemValue(cint(0))

    @do_while
    def _():
        input = sint.get_private_input_from(player)
        #print_ln("input reveal %s", input.reveal())

        if_then(input.reveal() != NULL)
        cust_vector.push_back(input)
        i.write(i + 1)
        #print_ln("input available")

        else_then()
        condition.write(0)
        #print_ln("end of input")
        end_if()

        #print_ln("%s", condition)
        return condition > 0

    close_channel(channel)

x = CustVector()

get_external_private_array(x, 5, 1)

x.show()
print_ln("=============")

length = x.length()
element = x.back()

print_ln("length: %s", length.reveal())
print_ln("elemnt: %s", element.reveal())

##########################===================
# def train_test_split(x_array, y_array, split):
#     x_test = sfloat.Array(15)
#     y_test = sfloat.Array(15)
#     # x_copy_array = x_array
#     # y_copy_array = y_array
#
#     get_nbit(x_test)
#         # not sure if it is more efficient to call get_nbit
#     # index = sint.get_random_int(get_nbit(x_test))
#     # # check if index within range of x_test array
#     # @while_do(index >= len(x_test))
#     # def _(j):
#     #     index = sint.get_random_int(get_nbit(x_test))
#     # return
#     # # if fraction of -1s is large, do rearrangement to new array
#     #     # x_text = rearange(x_test)
#     # return i+1
#
# # get number of bits to create random int
# def get_nbit(array):
#     arr_length = sfix(len(array))
#     log2_length = mpc_math.log2_fx(arr_length)
#     nbit = mpc_math.floor_fx(log2_length) + 1
#     nbit = floatingpoint.Trunc(nbit.v, nbit.k - nbit.f, nbit.f, nbit.kappa)
#     print_ln("%s", type(nbit))
#     nbit = nbit.reveal()
#     print_ln("%s", type(nbit))
#     yo = nbit.k
#     print_ln("%s", type(yo))
#     print_ln("%s", yo)
#
#     return nbit
#
# # print_ln("++++++++++++++")
# # print_ln("%s", log2_x.reveal())
# # print_ln("%s", exponent.reveal())
# # print_ln("++++++++++++++")
#
# train_test_split(x_tr, y_tr, sfloat(0.6))

#################################=====================


###########
#
# def get_array_lengths(array, split):
#     count = MemValue(sint(0))
#     condition = MemValue(cint(1))
#
#     # while loop running through array stopping at -123456789 and counting elements
#     @do_while
#     def _():
#         print_ln("array[count] %s", array[count.reveal()].reveal())
#         if_then(array[count.reveal()].reveal() == -123456789)
#         condition.write(0)
#
#         else_then()
#         count.write(count + 1)
#         end_if()
#
#         return condition > 0
#
#     print_ln("length %s", count.reveal())
#
#
#     # workaround by first casting count to sint, since direct cast from
#     # MemValue to sfloat not possible
#     length_sint = sint(count)
#     length_sfloat = sfloat(length_sint)
#
#     length_train = length_sfloat * sfloat(split)
#     print_ln("ll %s", length_train.reveal())
#     # round length_train up
#     # TODO implement this with FLRound
#     length_train = sfix(length_train)
#     length_train = mpc_math.floor_fx(length_train) + 1
#
#     length_test = sfix(len(array)) - length_train
#     print_ln("ltrain %s", length_train.reveal())
#     print_ln("ltest %s", length_test.reveal())
#     return length_train, length_test
#
# # get number of bits to create random int
# def get_nbit(l_train):
#     log2_length = mpc_math.log2_fx(l_train)
#     nbit = mpc_math.floor_fx(log2_length) + 1
#     return nbit
#
# # split data set into train and test set
# def split_up(array, split):
#     # initi x_train and x_test (array length has to be known at compile time,
#     # therefore, initialization with taking split into acocunt not possible)
#     x_train = sfloat.Array(MAX_ARRAY_LENGTH)
#     x_test = sfloat.Array(MAX_ARRAY_LENGTH)
#
#     length_train, length_test = get_array_lengths(array, split)
#     print_ln("ltrain %s", length_train.reveal())
#     print_ln("ltest %s", length_test.reveal())
#     print_ln("ttrain %s", type(length_train))
#     print_ln("ttest %s", type(length_test))
#
#     nbit = get_nbit(length_train)
#     print_ln("%s", nbit.reveal())
#     print_ln("%s", type(nbit))
#
#     # cast sfix to sint
#     nbit = floatingpoint.Trunc(nbit.v, nbit.k - nbit.f, nbit.f, nbit.kappa)
#     print_ln("%s", nbit.reveal())
#     print_ln("%s", type(nbit))
#
#     # create source of randomness
#     index = sint.get_random_int(4)
#     print_ln("%s", index.reveal())
#
#
#     # every
#
# test_arr = sint.Array(21)
#
# @for_range(20)
# def _(i):
#     test_arr[i] = i
#
# test_arr[18] = -123456789
# print_ln("======= array =====")
# @for_range(21)
# def _(i):
#     print_ln("%s", test_arr[i].reveal())
#
# split = 0.6
# length = len(test_arr)
# print_ln("%s", length)
# print_ln("%s", type(length))
# split_up(test_arr, split)
#
#
# def train_test_split(x_array, y_array, split):
#     train_size = split * sint(len(x_array))
#     test_size = len(x_array) - train_size
#     x_train = sfloat.Array(train_size)
#     y_train = sfloat.Array(train_size)
#     x_test = sfloat.Array(test_size)
#     y_test = sfloat.Array(test_size)
#     # x_copy_array = x_array
#     # y_copy_array = y_array
#
#     @while_do(lambda a: a <= train_size, 0)
#     def _(i):
#         # not sure if it is more efficient to call get_nbit
#         index = sint.get_random_int(get_nbit(x_test))
#         # check if index within range of x_test array
#         @while_do(index >= len(x_test))
#         def _(j):
#             index = sint.get_random_int(get_nbit(x_test))
#         return
#         # if fraction of -1s is large, do rearrangement to new array
#             # x_text = rearange(x_test)
#         return i+1
#


# sum function
def sum(array):
    result_array = sfloat.Array(1)
    result_array[0] = 0.0
    @while_do(lambda a: a < len(array), 0)
    def _(i):
        result_array[0] = result_array[0] + array[i]
        return i+1
    return result_array[0]

# mean function
def mean(array):
    return sum(array) / sfloat(len(array))

# rmse_metric
def rmse_metric(actual, predicted):
    sum_err = sfloat.Array(1)
    sum_err[0] = 0.0
    rmse = sfloat(0.0)

    @for_range(len(actual))
    def _(i):
        prediction_err = predicted[i] - actual[i]
        sum_err[0] += (prediction_err ** 2)
    mean_err = sum_err[0] / sfloat(len(actual))
    rmse = mpc_math.sqrt_simplified_fx(sfix(mean_err))
    return rmse

# covariance
def covariance(x_array, x_mean, y_array, y_mean):
    covar = sfloat.Array(1)
    covar[0] = 0.0
    @for_range(len(x_array))
    def _(i):
        covar[0] = covar[0] + (x_array[i] - x_mean) * (y_array[i] - y_mean)
    return covar[0]

# variance
def variance(array, mean):
    var = sfloat.Array(1)
    var[0] = 0.0
    # TODO try this with a address allocation (documentaion page 41)
    @for_range(len(array))
    def _(i):
        var[0] = var[0] + (array[i] - mean) ** 2
    return var[0]

# coefficients
def coefficients(x_array, y_array):
    x_mean = mean(x_array)
    y_mean = mean(y_array)
    b1 = covariance(x_array, x_mean, y_array, y_mean) / variance(x_array, x_mean)
    b0 = y_mean - b1 * x_mean
    return b0, b1

# slr algorithm
def simple_linear_regression(x_train, x_test, y_train):
    predictions = sfloat.Array(len(x_test))
    b0, b1 = coefficients(x_train, y_train)
    @for_range(len(x_test))
    def _(i):
        predictions[i] = b0 + b1 * x_test[i]
    return predictions

# evaluate
def evaluate(x_train, x_test, y_train, y_test):
    predicted = simple_linear_regression(x_train, x_test, y_train)
    rmse = rmse_metric(y_test, predicted)
    return rmse


# rmse = evaluate(x_tr, x_te, y_tr, y_te)
# print_ln("==========================")
# print_ln("RMSE: %s", rmse.reveal())
# print_ln("==========================")
